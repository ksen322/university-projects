# Изучение методов и прототипирование алгоритмов обработки изображений в системе для математических вычислений Octave  

Работа проводится в прогаммной среде для математических вычислений <a href = 'https://octave.org/'>Octave</a>
## Задачи проекта:  
1. Загрузка исходного изображения, отображение его в цвете, отображение в черно-белом варианте  
2. Обработка изображения с помощью фильтров (в данной работе используется метод Andy), нахождение и обозначение цветом объектов
3. Нахождение контура объекта, определение его площади, центра и построение контура объекта и окружности, описывающую объект
4. Обработка исходного изображения, используя 3D визуализацию

## Загрузка пакетов и изображения в проект Octave  

Перед началом работы с изображениями в Octave необходимо подключить пакеты <a href = 'https://gnu-octave.github.io/packages/image/'>Image</a> и <a href = 'https://gnu-octave.github.io/packages/geometry/'>Geometry</a> с помощью `pkg load`, после загружаем изображение с помощью команды *imread*.  
```
pkg load image  %загрузка пакет Image
pkg load geometry  %загрузка пакет Geometry
im = imread('E:\project\fish.jpg');  %загрузка изображения в переменную im с путем
```
В параметрах imread должен быть путь к изображению.  

## Преобразование цветного изображения в черно-белое и вывод этих изображений  

Изменим изображение на черно-белое, оно будет состоять из разных оттенков серого. Для этого нужно найти среднее арифметическое трех матриц (цветов). 
Обратимся к каждой матрице и будем перебирать все столбцы и строки с помощью символа «:». Переменная *im_bw* содержит тип данных double. Функция *imshow* выводит на экран изображение в графическом режиме TrueColor.  
```
im_bw = (double(im(:,:,1)) + double(im(:,:,2)) + double(im(:,:,3))) / 3;  %усредняем значения оттенков
figure(1)  %запуска отдельного окна
subplot(2,1,1)  %задаем место для загрузки первичного изображения
imshow(im)  %загрузка этого изображения
subplot(2,1,2)
imshow(im_bw, [0 255])  %загрузка черно-белого изображения (точного)
```

Получаем результат:  

![image](https://github.com/ksen322/university-projects/assets/119673458/1168c9eb-58fe-4a19-837f-b1320a2c260a)  

## Обработка изображения с помощью фильтров  
Для выделения контура объектов используем функцию *edge*. Обнаружение границ производим методом *Andy*.  

Наиболее общим способом поиска разрывов является обработка изображения с помощью скользящей маски, называемой также фильтром (шаблоном), которая представляет собой матрицу, соответствующую указанной группе пикселей исходного изображения. Элементы матрицы называются коэффициентами. Оперирование такой матрицей в каких-либо локальных преобразованиях называется фильтрацией.  

Создадим маску с помощью фильтра Гаусса. Для этого используем команду *fspecial* с параметром *gaussian*. Затем применим эту маску с помощью команды *imfilter*. У получившегося изображения определим границы объекта методом *Andy* с порогом 10. С помощью команды *bwareafilt* определим уникальные объекты на получившемся изображении. После, используя функцию *bwfill*, выполняем заливку промежутков для нахождения точного контура объекта.

```
f = fspecial("gaussian", [5 5], 1);  % возвращает вращательно симметричный фильтр Гаусса % заданного размера с единичным отклонением 
im_f = imfilter(uint8(im_bw), f);  % фильтрует матрицу черно-белого изображения с %фильтром f
im_e = edge(im_f, 'Andy', 10); %определение границы объекта im_f методом Andy с %порогом 10
im_c = bwareafilt(im_e, 1); %определяем уникальные объекты на изображении
im_cf = bwfill(im_c, 'holes'); % выполняем заливку промежутков для более точного контура

figure(2)
subplot(2,2,1)
imshow(im_e)
subplot(2,2,2)
imshow(im_c)
subplot(2,2,3)
imshow(im_cf)
```
Получаем результат:  

![image](https://github.com/ksen322/university-projects/assets/119673458/44159626-e90f-4303-878d-9c48ab98da62)  

## Определение параметров объекта и вывод изображений  
### Определение контура объекта  
Для выделения контура объекта воспользуемся функцией *bwboundaries*. Она возвращает координаты строк и столбцов всех пикселей, которые принадлежат границе объектов изображения. Матрица будет, соответственно, состоять из двух столбцов.  
```
b = bwboundaries(im_cf);  %возвращаем координаты строк и столбцов всех пикселей, %которые принадлежат границе объектов изображения
bx = cell2mat(b(1))(:,2);  %координаты строки матрицы
by = cell2mat(b(1))(:,1);  %координаты столбца матрицы
size(b)  %вектор-строка
```
Запишем координаты строки и столбца матрицы в переменные *bx* и *by*.  
### Вычисление площади объекта  
Вычислим площадь с помощью функции *polygonArea*. В параметрах задаются координаты матрицы.  

` A = polygonArea([bx by])  % вычисляем площадь объекта `  

### Вычисление радиуса окружности  
Найдем радиус с помощью формулы `sqrt(A/pi)`, где sqrt – функция для извлечения квадратного корня из какого-либо числа, A – площадь (уже найденная, когда вычисляли площадь объекта).  
` r = sqrt(A / pi)  %радиус объекта `

### Нахождение центра этого объекта  
Найдем центр с помощью функции *polygonCentroid*.  
` C = polygonCentroid([bx by])  %определение центра объекта `  

### Окрашивание выделенной зоны объекта  
Присвоим переменной *im_z* информацию об исходном изображении. Затем обратимся ко второму каналу матрицы im (зеленый цвет), которая содержит информацию об изначальном изображении, и усилим яркость коэффициента области im_cf в 100 раз, сложим и получим подкрашенную зеленым цветом зону объекта.  
```
im_z = im;  % задаем информацию об исходном изображении
im_z(:,:,2) = im(:,:,2) + im_cf * 100;  %обращение ко второму каналу матрицы (зеленый цвет)
figure(3)
imshow(im_z)  % отображение im_z
hold on
plot(bx, by, '-g', 'LineWidth', 3)  % рисуем контур объекта
drawCircle(C(1), C(2), r, '-r', 'LineWidth', 2)  % рисуем окружность вокруг объекта радиуса r % c центром в (1;2)
hold off
```
### Отображением контура и окружности на изображении  
В окне figure(3) рисуем контур (функция *plot*) и окружность (функция *drawCircle*) вокруг объекта радиуса r с центром в точке C.  

Получаем результат:  

![image](https://github.com/ksen322/university-projects/assets/119673458/1b6da61e-055a-4244-9edb-41e37e50a5a0)  

## 3D визуализация  
*plot3(x, y, z)* – функция отвечает за построение трехмерных линий, где x, y, z являются одномерными массивами координат точек.  
Функция *impyramid* (с параметром reduce) позволяет уменьшить разрешение изображения. Уменьшаем разрешение объекта *im_bw* в 3 раза – получаем объект im_rrr.  
```
im_r = impyramid(im_bw, 'reduce'); %уменьшение разрешения изображения
im_rr = impyramid(im_r, 'reduce');
im_rrr = impyramid(im_rr, 'reduce');
figure(4) 
```
Для построения трехмерной поверхности используем функцию *surf*. Функция *surf* выполняет построение каркасного графика с заливкой каждой клетки цветом, который зависит от значения функции в узлах сетки.  
```
surf(im_rrr)  %построение трехменой поверхности с заливкой каждой клетки цветом,   %который зависит от значения функции в узлах сетки
hold on 
```
В окне figure(4) отобразим трехмерную поверхность объекта *im_rrr* и трехмерный контур.  
Заметим, что в функции *plot3* использовали умножение на 255 для того, чтобы затронуть все слои объекта и контур полностью отрисовался поверх изображения.  
```
plot3(bx / 8, by / 8, ones(size(bx)) * 255, '-r', 'LineWidth', 3)  %отображаем контур
hold off
```
С помощью xlim, ylim, zlim обозначаем границы трехмерной сетки.  
```
xlim([0 150])  %предел трехмерной сетки по x координате
ylim([0 100])  %предел трехмерной сетки по y координате
zlim([0 255])  %предел трехмерной сетки по z координате
```
Получаем результат:  

![image](https://github.com/ksen322/university-projects/assets/119673458/f92242ff-9f02-4372-ac69-ddc4ec681db4)  

![image](https://github.com/ksen322/university-projects/assets/119673458/2a10b285-63a5-4a10-9667-5202d6945e5e)

